//1. LCM code
DATA SEGMENT
NUM DW 5,4
LCM DW 2 DUP(0)
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV DX,0
MOV AX,NUM
MOV BX,NUM+2
UP:
PUSH AX
PUSH DX
DIV BX
CMP DX,0
JE EXIT
POP DX
POP AX
ADD AX,NUM
JNC DOWN
INC DX
DOWN:
JMP UP
EXIT:
POP LCM+2
POP LCM
MOV AX,LCM
MOV AH,4CH
INT 21H
CODE ENDS
END START
//2.GCD code
DATA SEGMENT
    NUM1 DW 000AH
    NUM2 DW 0004H
    GCD DW ?
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    MOV AX,NUM1
    MOV BX,NUM2 
    
    COMPARE:CMP AX,BX
    JE EXIT
    JB SWAP
    
    DIVIDE:MOV DX,0H
    DIV BX
    CMP DX,0
    JE EXIT
    MOV AX,DX
    JMP COMPARE 
    
    SWAP:XCHG AX,BX
    JMP DIVIDE
    
    EXIT:MOV GCD,BX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//3.Factorial code
DATA SEGMENT
    X DW 06H
    FACT DW ?
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    MOV AX, 01H
    MOV CX, X
UP:
    MUL CX
    LOOP UP
    MOV FACT, AX
    MOV AH, 4CH
    INT 21H
CODE ENDS
END START
//4.Square_Cube code   
DATA SEGMENT
X DW 04H
SQUARE DW ?
CUBE DW ?
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AX,X
MOV BX,X
MUL BX
MOV SQUARE,AX
MUL BX
MOV CUBE,AX
MOV AH,4CH
INT 21H
CODE ENDS
END START
//.5 positive/negative code
DATA SEGMENT
NUM DB 12H
MSG1 DB 10,13,'DATA IS POSITIVE $'
MSG2 DB 10,13,'DATA IS NEGATIVE $'
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AL,NUM
ROL AL,1
JC NEGA
MOV DX,OFFSET MSG1
JMP EXIT

NEGA:
MOV DX,OFFSET MSG2

EXIT:
MOV AH,09H
INT 21H
MOV AH,4CH
INT 21H
CODE ENDS
END START
//6.Odd/Even code
DATA SEGMENT
X DW 27H
MSG1 DB 10,13,'NUMBER IS EVEN $'
MSG2 DB 10,13,'NUMBER IS ODD $'
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AX,X
TEST AX,01H
JNZ ODD
LEA DX,MSG1
MOV AH,09H
INT 21H
JMP LAST
ODD:
LEA DX,MSG2
MOV AH,09H
INT 21H
LAST:
MOV AH,4CH
INT 21H
CODE ENDS
END START
//7.Equation code
DATA SEGMENT
X DB 28
Y DB ?
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AL,X
SUB AL,30
NEG AL
MOV BL,5
MUL BL
MOV BL,9
DIV BL
ADD AL,7
MOV Y,AL

EXIT:
MOV AH,4CH
INT 21H
CODE ENDS
END START
//AvgCalculation code
DATA SEGMENT
SUM DW 0
AVG DW 0
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV CX,50
MOV BX,1
MOV AX,0

SUM_LOOP:
ADD AX,BX
INC BX
LOOP SUM_LOOP

MOV SUM,AX
MOV AX,SUM
MOV CX,50
DIV CX
MOV AVG,AX

MOV AH,4CH
INT 21H
CODE ENDS
END START
//Fibonacci Series
DATA SEGMENT
FIB DW 15 DUP(0)
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV AX,0
MOV FIB[0],AX
MOV AX,1
MOV FIB[2],AX

MOV CX,13
MOV SI,4

FIB_LOOP:
MOV AX,FIB[SI-4]
MOV BX,FIB[SI-2]
ADD AX,BX
MOV FIB[SI],AX
ADD SI,2
LOOP FIB_LOOP

MOV AH,4CH
INT 21H
CODE ENDS
END START
//Reverse num
DATA SEGMENT
NUM DW 1234
REV DW 0
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV AX,NUM
MOV BX,0

REV_LOOP:
CMP AX,0
JE DONE
MOV DX,0
MOV CX,10
DIV CX
MOV CX,BX
MUL 10
ADD BX,DX
JMP REV_LOOP

DONE:
MOV REV,BX

MOV AH,4CH
INT 21H
CODE ENDS
END START
//Palindrome code
DATA SEGMENT
NUM DW 12321
REV DW 0
MSG1 DB 'NUMBER IS PALINDROME $'
MSG2 DB 'NUMBER IS NOT PALINDROME $'
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV AX,NUM
MOV BX,0

PAL_LOOP:
CMP AX,0
JE CHECK
MOV DX,0
MOV CX,10
DIV CX
MOV CX,BX
MUL 10
ADD BX,DX
JMP PAL_LOOP

CHECK:
MOV REV,BX
MOV AX,NUM
CMP AX,BX
JE IS_PAL
JMP NOT_PAL

IS_PAL:
MOV AH,09H
LEA DX,MSG1
INT 21H
JMP EXIT

NOT_PAL:
MOV AH,09H
LEA DX,MSG2
INT 21H

EXIT:
MOV AH,4CH
INT 21H
CODE ENDS
END START
//LargestNumFind code
DATA SEGMENT
X DW 0010H,52H,30H,40H,50H
MAX DW ?
COUNT DW 5
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV SI,OFFSET X
MOV CX,COUNT
MOV AX,[SI]
MOV BX,AX

NEXT:
ADD SI,2
LOOP_CHECK:
DEC CX
JZ DONE
MOV AX,[SI]
CMP AX,BX
JBE SKIP
MOV BX,AX
SKIP:
JMP NEXT

DONE:
MOV MAX,BX
MOV AH,4CH
INT 21H
CODE ENDS
END START
//SmallestNumFind code
DATA SEGMENT
X DW 0010H,52H,30H,40H,50H
MIN DW ?
COUNT DW 5
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV SI,OFFSET X
MOV CX,COUNT
MOV AX,[SI]
MOV BX,AX

NEXT:
ADD SI,2
DEC CX
JZ DONE
MOV AX,[SI]
CMP AX,BX
JAE SKIP
MOV BX,AX
SKIP:
JMP NEXT

DONE:
MOV MIN,BX
MOV AH,4CH
INT 21H
CODE ENDS
END START
//Asecnding order(bubblesort) code
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV CX,COUNT
DEC CX                 ; outer loop counter = n-1

OUTER:
MOV SI,0               ; SI = starting index
MOV DX,CX              ; inner loop counter

INNER:
MOV AX,NUM[SI]
MOV BX,NUM[SI+2]
CMP AX,BX
JBE SKIP_ASC            ; if AX <= BX, skip
XCHG AX,BX
MOV NUM[SI],AX
MOV NUM[SI+2],BX

SKIP_ASC:
ADD SI,2
DEC DX
JNZ INNER

DEC CX
JNZ OUTER

MOV AH,4CH
INT 21H
CODE ENDS
END START
//Descending order sort code
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV CX,COUNT
DEC CX

OUTER_DESC:
MOV SI,0
MOV DX,CX

INNER_DESC:
MOV AX,NUM[SI]
MOV BX,NUM[SI+2]
CMP AX,BX
JAE SKIP_DESC      ; if AX >= BX, skip
XCHG AX,BX
MOV NUM[SI],AX
MOV NUM[SI+2],BX

SKIP_DESC:
ADD SI,2
DEC DX
JNZ INNER_DESC

DEC CX
JNZ OUTER_DESC

MOV AH,4CH
INT 21H
CODE ENDS
END START

8.16bitAddition code
DATA SEGMENT
NUM DW 1234H,0F234H
SUM DW 2 DUP(0)
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AX,NUM
MOV BX,0
ADD AX,NUM+2
JNC DOWN
INC BX
DOWN:
MOV SUM,AX
MOV SUM+2,BX
MOV AH,4CH
INT 21H
CODE ENDS
END START
// 32BitAddition code
DATA SEGMENT
    NUM1 DW 0FFFFH,0FFFFH
    NUM2 DW 1111H,1111H
    SUM DW 4 DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    MOV AX,NUM1
    ADD AX,NUM2
    MOV SUM,AX
    MOV AX,NUM1+2
    ADC AX,NUM2+2
    JNC EXIT
    MOV SUM+4,01H
    
    EXIT:MOV SUM+2,AX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//Sqrt code
DATA SEGMENT
X DW 25
SQRT DW 0
SQUARE DW 0
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX

MOV AX,X
MOV CX,0       ; candidate for sqrt

SQRT_LOOP:
INC CX
MOV BX,CX
MUL BX
CMP AX,BX
JG SQRT_LOOP

DEC CX
MOV SQRT,CX

MOV AX,CX
MUL CX
MOV SQUARE,AX

MOV AH,4CH
INT 21H
CODE ENDS
END START
//16bitSubstraction code
DATA SEGMENT
    NUM DW 4567H,2345H
    DIF DW 1 DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    CLC
    LEA SI,NUM
    MOV AX,[SI]
    SBB AX,[SI+2]
    MOV DIF,AX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//.32bitSubstraction code
DATA SEGMENT
    NUM1 DW 2345H,6762H
    NUM2 DW 1111H,1111H
    DIF DW 2 DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    LEA SI,NUM1
    LEA DI,NUM2
    MOV AX,[SI]
    MOV BX,[DI]
    SUB AX,BX
    MOV DIF,AX
    INC SI
    INC SI
    INC DI
    INC DI
    MOV AX,[SI]
    MOV BX,[DI]
    SBB AX,BX
    MOV DIF+2,AX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
// 8bitDivisionSignNum code
DATA SEGMENT
    NUM1 DB -10
    NUM2 DB 02
    QUO DB 1 DUP(0)
    REM DB 1 DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    MOV AL,NUM1
    CBW
    IDIV NUM2
    MOV QUO,AL
    MOV REM,AH
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//8bitDivisionUnsignedNum code
DATA SEGMENT
    NUM1 DB 72H
    NUM2 DB 02H
    QUO DB 1 DUP(0)
    REM DB 1 DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    MOV AL,NUM1
    MOV AH,0H
    DIV NUM2
    MOV QUO,AL
    MOV REM,AH
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START 
//16BitDivisionUnsignedNum code
DATA SEGMENT
     NUM1 DW 4567H,2345H
     NUM2 DW 4111H
     QUO DW 2 DUP(0)
     REM DW 1 DUP(0)
     DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    MOV AX,NUM1
    MOV DX,NUM1+2
    DIV NUM2
    MOV QUO,AX
    MOV REM,DX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//1BitDivSigned code
DATA SEGMENT
     NUM1 DW 4567H,2345H
     NUM2 DW 4111H
     QUO DW 2 DUP(0)
     REM DW 1 DUP(0)
     DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    MOV AX,NUM1
    MOV DX,NUM1+2
    DIV NUM2
    MOV QUO,AX
    MOV REM,DX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//16bitDivSigned code
DATA SEGMENT 
NUM1 DW 4567H,2345H 
NUM2 DW 4111H 
QUO DW 2 DUP(0) 
REM DW 1 DUP(0) 
DATA ENDS 
CODE SEGMENT 
ASSUME CS:CODE,DS:DATA
START: MOV AX,DATA 
MOV DS,AX 
MOV AX,NUM1 ; Move the lower bit of Dividend to AX 
MOV DX,NUM1+2   ; Move the higher bit of Dividend to DX 
CWD 
IDIV NUM2        ; Perform the sign Division operation using IDIV 
MOV QUO,AX    ; Store the quotient to AX 
MOV REM,DX     ; Store the reminder to DX 
MOV AH,4CH 
INT 21H 
CODE ENDS 
END START 
 
INPUT: Dividend - -44444444, 
Divisor - 2222, 
0UTPUT: AX – FE (quotient);      
DX – FF (reminder)    ; Result is in two complement form.
//16BitSignedMultiplication code
DATA SEGMENT
    NUM DW 1234H,1234H
    PROD DW 2 DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    LEA SI,NUM
    MOV AX,[SI]
    MOV BX,[SI+2]
    MUL BX
    MOV PROD,AX;    5A90
    MOV PROD+2,DX;   014B
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//16BitUnsignedMultiplication code
DATA SEGMENT
    NUM DW -2,1
    PROD DW 2DUP(0)
    DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
    START:MOV AX,DATA
    MOV DS,AX
    LEA SI,NUM
    MOV AX,[SI]
    MOV BX,[SI+2]
    IMUL BX
    MOV PROD,AX
    MOV PROD+2,DX
    MOV AH,4CH
    INT 21H
    CODE ENDS
END START
//binary to BCD conversion 
DATA SEGMENT
BIN DW 01A9H
BCD DB 2 DUP(0)
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AX,BIN
MOV CL,64H
DIV CL
MOV BCD+1,AL
MOV AL,AH
MOV AH,00H
MOV CL,0AH
DIV CL
MOV CL,04
ROR AL,CL
ADD AL,AH
MOV AH,4CH
INT 21H
CODE ENDS
END START
//BCD to binary conversion
DATA SEGMENT
BCD DW 27H
BIN DW ?
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AX,BCD
AND AX,07H
MOV BX,AX
MOV AX,BCD
AND AX,0F0H
MOV CX,0AH
MUL CX
ADD AX,BX
MOV BIN,AX
MOV AH,4CH
INT 21H
CODE ENDS
END START

